### 알고리즘 

도둑잡기
https://programmers.co.kr/learn/courses/30/lessons/42897

별찍기
https://www.acmicpc.net/problem/2447

석판
https://www.acmicpc.net/problem/2339

유기농배추
https://www.acmicpc.net/problem/1012



### 취업스터디 (2시간)

<이번주>

1. OS 분야 질문

### 질문 및 정답 <OS 관련 질문>

* 재호

1. 쓰레드 세이프에 대한 개념
   -> Thread-safe의 개념에 대해 설명하세요. (K사 전화면접)
   Thread safe는 멀티 스레드 프로그래밍 환경에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없는 것을 말한다.

Thread-safe한 코드를 만들기 위해서는 Critical Session을 통해 스레드 내부에서 처리되는 연산들을 직렬화 하여 한 번에 한 스레드에서 연산이 수행되도록 만들어 주어야 한다.

2. 메모리 관련해서
   메모리 단편화가 있는데 내부단편화가 있고 외부 단편화가 있는데 그것에 대한 해결방법

3. 프로세스 종료 4가지
   1) 주 쓰레드의 진입점 함수가 반환된다.
      프로세스가 종료되어야 할 때에는 항상 주 쓰레드의 진입점 함수가 반환하도록 애플리케이션을 설계하는 것이 좋다. 이 방법만 유일하게 주 쓰레드의 리소스들이 적절히 해제되는 것을 보장할 수 있다.

   2) 프로세스 내의 어떤 쓰레드가 ExitProcess 함수를 호출한다.
      이 함수는 프로세스를 종료시키고 fuExitCode로 프로세스의 종료 코드를 설정한다. 당연히 반환값도 없고 이 함수의 뒤의 코드들은 무시된다.

   3) 다른 프로세스의 쓰레드가 TerminateProcess함수를 호출한다.
      TerminateProcess함수 와 ExitProcess함수는 차이점이 있다. TerminateProcess함수는 자신의 프로세스 뿐만 아니라 다른 프로세스까지도 종료시킬 수 있다. hProcess 매개변수로 종료시키고자 하는 프로세스의 핸들을 전달하면 된다. 프로세스가 종료되면 fuExitCode 매개변수로 전달한 값이 종료 코드로 설정된다.

   4) 프로세스 내의 모든 스레드가 각자 종료된다.
      운영체제는 프로세스의 주소 공간 상에 위치하는 코드를 수행할 쓰레드가 없기 때문에, 프로세스를 종료시킨다.

      -> 종료되는 과정
      ExitProcess가 호출된 이후 프로세스가 본격적으로 종료되는 과정은 아래와 같다.
      남아 있는 모든 쓰레드가 종료된다.
      프로세스에 의해 할당된 모든 사용자 오브젝트(전역, static), GDI 오브젝트가 삭제되고, 모든 커널 오브젝트는 usage count가 1 감소한다. (atexit 함수에 의해 수행된다)
      프로세스의 종료 코드는 STILL_ACTIVE에서 ExitProcess/TerminateProcess 호출시 설정한 종료 코드로 변경된다.
      프로세스 커널 오브젝트의 상태가 시그널 상태로 변경된다.
      프로세스 커널 오브젝트의 usage count가 1 감소한다.
      특히, 전역/static이 진입점 함수가 반환된 이후에 소멸됨을 명심하라.
      시작 과정에서도 살펴 보았듯이, 전역/static 오브젝트들은 우리가 제어할 수 있는 영역 밖에서 생성/소멸된다.
   

1)치명적인 오류 를 발생했을떄 



---



* 현식

1.프로세스와 쓰레드 차이 (메모리적,)
2.세마포어와 뮤텍스 차이

1. 멀티쓰레딩과 멀티프로세싱이 있는데 멀티프로쓰레딩을 쓰라고 하는데 왜 쓸까요??

<프로세스 종료 4가지>

1. Normal exit

- process가 마지막 문장을 수행하고 OS가 결정(running 상태에서 종료)
  ex) Windows: ExitProcess, Unix: exit

2. Error exit
   -치명적인 오류를 발견한 경우(보통 running상태에서 종료)
   ex) cc foo.c -> foo.c 파일이 없는 경우

3. Fatal error
   -프로그램의 버그에 기인한 종료
   ex) 부적절한 명령어, 존재하지 않는 메모리 참조, 0으로 나눗셈하기

4. Killed by another process
   -한 프로세스의 시스템 호출에 의한 다르 프로세스 종료(running, blocked, ready상태에서 모두 종료 가능)
   ex) Windows: 강제종료, Unix: kill


<프로세스 실행시 상태변화 3가지>

1. Running
   -프로세스 입장에서 실제로 CPU를 사용하는 상태(명령어를 실행시키는 상태)

- Running상태 프로세스는 코어 1개당 하나임.

2. Ready

- 다른 프로세스를 실행하기 위하여 일시 정지하고 있는 상태이며 실행 가능한 상태이다.(queue 사용)

3. Blocked(=waiting)
   -어떤 외부 사건(대부분 I/O)이 일어날 때까지 실행 될 수 없는 대기 상태이다.
   ex) scanf가 키보드로부터 입력 받기 전까지


<스레드 종류 2가지>

1. user threads

- 커널의 지원 없이 스레드 관리 가능
- 스레드 관리는 user-level threads library에 의해 수행
- 생성과 관리가 빠름

2. kernel threads

- 커널(OS)에 의해 지원되고 관리
- 대부분의 OS는 kernel-level thread를 지원함

* 정혁

1. 페이징 교체를 하는데 언제 페이지 교체의 목적
   * 언제 페이징 교체가 이루어 질까? 
     * 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다. 하지만, 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄져야 한다.
   * 페이징 교체 자체에서 "목적"과 "언제 페이징 교체가 이루어질까" 는 일맥상통하는 부분이 있다.
2. 세그멘테이션이 무엇일까요?
   * 세그멘테이션은 가상 메모리 관리 기법중 하나로 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할하고 메모리를 할당하는 기법이다.
   * 메모리에 적재될때 빈공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법
3. 프로세스 실행시 상태변화 3가지
   * new , running, waiting, ready, terminate
     * running
       * 프로세스가 cpu를 할당받아 실제로 명령어들을 수행중인 상태
     * waiting
       * running상태에 있던 프로세스가 인터럽트가 발생하거나 특정 조건이 필요할 시에 waiting상태(ex: 외부입력 데이터가 필요시 대기)
     * ready
       * waiting상태에서 기다리던 프로세스가 사건이 만족되면 ready상태가 되며, cpu를 사용중인 프로세스가 cpu반환시에 cpu를 할당 받을 수 있는 후보가 된다.

---



* 현우

1. 캐쉬와 가상메모리의 차이
   2.쓰레드에서 유저쓰레드와 커널쓰레드 차이

2. 프로세스와 쓰레드의 차이

   * 프로세스 
     메인 메모리에서 실행되고 있는 프로그램의 인스턴스(독립적인 개체)이다. 즉 OS로 부터 system 자원 할당을 받는 작업의 단위이다.
   * 쓰레드
     프로세스가 할당 받은 자원을 이용하는 실행의 단위.

   프로세스는 cpu의 시간, 주소공간, code,data, stack, heap 구조의 독립된 메모리 영역을 갖지만 쓰레드는 stack만 따로 할당 받고 그 외는 공유한다.

