# 동기 비동기 / 블로킹 논블로킹

## 1. 동기(Synchronous)와 비동기(Asynchronous)개념

- **동기**는 요청과 그 결과가 동시에 일어난다는 뜻이며
  - 즉, 어떤 객체 또는 함수 내부에서 다른 함수로 호출했을 때 이 **함수의 결과를 호출한 쪽에서 처리하면 동기**이다.
- **비동기**는 요청과 그 결과가 동시에 일어나지 않는다는 뜻이며, 
  - 동기와 달리 어떤 객체 또는 함수 내부에서 다른 함수를 호출했을 때 이 **함수의 결과를 호출한 쪽에서 처리하지 않으면 비동기** 이다.

<br>

#### 1) 동기의 예

일반적으로 사용하는 함수들은 대부분 동기적 방식이다.

C언어의 scanf()와 Java의 Scanner객체의 next()메서드 같이 사용자의 입력을 받는 함수들이 그 예이다.

``` java
Scanner sc = new Scanner(System.in);
int num = sc.nextInt();
```

sc.nextInt 결과 사용자가 입력을 하면, 그 값은 num이라는 변수에 담긴다.

즉, num 변수는 nextInt() 메소드를 **호출하고 그 결과를 자신이 직접 처리 했다.**

따라서 위의 코드는 동기적 방식이라 할 수 있다.

<br>

#### 2) 비동기의 예

다음은 JS의 setTimeout() 함수이며, 비동기 방식의 예이다.

```javascript
setTimeout(foo,3000)

function foo(){
	console.log("2");
}
console.log("1");
```

setTimeout() 함수를 호출하면 3초 뒤에 foo() 함수가 수행되는 코드이다.

setTimeout() 함수를 호출한 후 3초라는 시간이 흘러야 foo() 함수가 수행되며, 이 시간 동안 프로그램은 다음 코드를 읽기 때문에, 위 코드는 콘솔에 1, 2 순서로 출력이 된다.

여기서 foo()함수를 setTimeout()함수의 **콜백( callback )함수**라고 한다.

**콜백 함수**란 비동기 방식에서 **어떤 수행이 완료되었을 때( event가 발생했을 때 ) 수행해야 할 함수**를 의미한다.

이처럼 비동기 방식에서는 **함수를 호출한 쪽에서 수행 결과를 직접 처리하지 않고 콜백 함수를 통해 수행 결과를 처리**한다.

이처럼 동기와 비동기는 수행의 결과를 함수를 호출한 쪽에서 직접 처리하느냐, 아니면 다른 곳에서 처리하느냐의 차이로도 볼 수 있다.

<br><br>

## 2. 블로킹(Blocking)과 논블로킹(non-blocking)

- **블로킹**은 자신의 수행결과가 끝날 때까지 제어권을 갖고 있는 것을 의미한다.
- **논블로킹**은 자신이 호출되었을 때 제어권을 바로 자신을 호출한 쪽으로 넘기며, 자신을 호출한 쪽에서 다른 일을 할 수 있도록 하는 것을 의미한다.

<br>

#### 1) 블로킹

동기 예제 코드에서는 사용자가 입력할 때까지 프로그램은 어떠한 동작도 수행하지 않는다.

즉, 사용자가 입력할 때까지 제어권은 nextInt()메소드에게 존재하며, 사용자가 입력을 해야만 제어권이 넘어가서 이후의 코드가 수행된다.

이처럼 수행 결과가 끝날 때까지 제어권을 갖고 있는 것이 blocking 방식이다.

 <br>

#### 2) 논블로킹

비동기 예제 코드의 수행 결과는 1, 2가 순서대로 출력된다.

그 이유는 setTimeout(foo, 3000) 함수를 호출할 때 제어권을 바로 반납하기 때문이다.

즉, 3초 뒤에 foo() 함수가 실행이 되지만, 제어권을 반납했기 때문에 바로 다음 코드인 console.log("1")가 수행이 된다.

그리고 나서 3초라는 시간이 흘렀다는 이벤트가 발생하여 콜백 함수인 foo() 함수가 수행이 되는 것이다.

이처럼 제어권을 바로 반납하는 방식을 non-blocking 방식이라 한다.

<br>

**★★★ 참고로 동기와 블로킹, 비동기와 논블로킹은 비슷해 보이지만 다른 개념이다.  **

위에서는 동기+블로킹, 비동기+논블로킹을 조합으로 개념설명을 하였다.

이제 부터 동기+논블로킹, 비동기+블로킹 조합을 설명하겠다.

<br>

#### 1. 동기+논블로킹

앞에서 살펴본대로 조합해보면 NonBlocking-Sync는 호출되는 함수는 바로 리턴하고, 호출하는 함수는 작업 완료 여부를 신경쓰는 것이다. 신경쓰는 방법이 기다리거나 물어보거나 두 가지가 있었는데, NonBlocking 함수를 호출했다면 사실 기다릴 필요는 없고 물어보는 일이 남는다.

즉, NonBlocking 메서드 호출 후 바로 반환 받아서 다른 작업을 할 수 있게 되지만, 메서드 호출에 의해 수행되는 작업이 완료된 것은 아니며, 호출하는 메서드가 호출되는 메서드 쪽에 작업 완료 여부를 계속 문의한다.

그림을 그려보면 다음과 같다.

<br>

![동기_논블로킹](https://user-images.githubusercontent.com/32161395/76162583-6ec0e700-6182-11ea-9626-cc34bf29b430.png)

<br>

```java
Future ft = asyncFileChannel.read(~~~);

while(!ft.isDone()) {
    // isDone()은 asyncChannle.read() 작업이 완료되지 않았다면 false를 바로 리턴해준다.
    // isDone()은 물어보면 대답을 해줄 뿐 작업 완료를 스스로 신경쓰지 않고,
    //     isDone()을 호출하는 쪽에서 계속 isDone()을 호출하면서 작업 완료를 신경쓴다.
    // asyncChannle.read()이 완료되지 않아도 여기에서 다른 작업 수행 가능 
}

// 작업이 완료되면 작업 결과에 따른 다른 작업 처리
```

참고로 위 코드는 NonBlocking-Sync라는 특성 이해에 집중할 수 있도록 간략화한 예제고, 실무적으로는 `Future`보다는 `CompletableFuture`를 쓰거나, `Future`를 쓴다면 위의 while 블록은 별도의 쓰레드로 빼서 실행하는 것이 좋다.

<br>

#### 2. 비동기+블로킹

앞에서 살펴본대로 조합해보면 Blocking-Async는 호출되는 함수가 바로 리턴하지 않고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않는 것이다.

그림을 그려보면 다음과 같다.

<br>

![비동기_블로킹](https://user-images.githubusercontent.com/32161395/76162655-10e0cf00-6183-11ea-93ec-4b161c11a1a2.png)

<br>

**Blocking-Async의 대표적인 케이스가 Node.js와 MySQL의 조합**이다.

Node.js 쪽에서 callback 지옥을 헤치면서 Async로 전진해와도, 결국 DB 작업 호출 시에는 MySQL에서 제공하는 드라이버를 호출하게 되는데, 이 드라이버가 Blocking 방식이라고 한다.

사실 이건 Node.js 뿐아니라 Java의 JDBC도 마찬가지다. 다만 Node.js가 싱글 쓰레드 루프 기반이라 멀티 쓰레드 기반인 Java의 Servlet 컨테이너보다 문제가 더 두드러져 보일 뿐, Blocking-Async라는 근본 원인은 같다.

결국

Blocking-Async는 별다른 장점이 없어서 일부러 사용할 필요는 없지만,

**NonBlocking-Async 방식을 쓰는데 그 과정 중에 하나라도 Blocking으로 동작하는 놈이 포함되어 있다면 의도하지 않게 Blocking-Async로 동작**할 수 있다.