### JAVA의 동기화



싱글 스레드에서 문제가 되지 않지만 멀티스레드에서 문제가 되지 않으나

멀티 스레드에서 문제가 되는 경우

경쟁 상태와 변수의 가시성 문제

* 경쟁 상태 (race condition)

  여러 스레드 같은 시점 변수를 읽는 상태

* 변수의 가시성 (visibility)

  변수들이 사용될 수 있는 영역의 범위

  변수의 값은 CPU 메모리와 메인 메모리에 저장된다.

  이 값을 CPU 메모리인지 메인 메모리에서 가져오는지 알 수 가 없다는 문제가 변수의 가시성 문제이다.

  CPU 메모리에서 값을 읽어들인다면 매우 안전하지 못하다. 

  그래서 동기화 방식을 스레드 자체만으로 해결하기도 한다.





#### 1. Synchronized

하나의 스레드가 lock을 얻어 수행이 끝날 때까지 다른 스레드들은 lock이 풀릴 때까지 대기하게 된다.

여러 스레드에서 읽기 쓰기 모두 이용할 수 있다.

Synchronized 를 걸면 그 함수가 포함된 해당 객체(this)에 lock을 거는 것과 같다.



* 장점

  따라서 동기화 문제를 해결하는데 가장 간단하고 무식한 방법이다.

  여기서 무식하다 함은 synchronized로 인하여 객체에 포함된 다른 모든 synchronized의 접근 까지 lock이 걸리기 때문입니다. 그래서 synchronized block 이 존재한다.

* 단점

  1. sync 키워드를 너무 남발하면 성능저하를 일으킬 수 있다.

  그 이유는 sync 키워드를 사용하면 자바 내부적으로 메서드나 변수에 동기화를 하기 위해 block과 unblock을 처리하게 되는데 이런 처리들이 만약 너무 많아지게 되면 오히려 프로그램 성능저하를 일으킬 수 있다.

  2. 특정 스레드가 해당 블럭 전체를 lock 을 하기 때문에 다른 스레드는 아무런 작업을 하지 못하고 기다리는 상황이 될 수 있기 때문에 낭비가 심하다.

     

Synchronized block의 사용

sync함수는 두가지 문제점이 있다.

1. synchronized 함수가 lock이 걸린다.
2. synchronized 함수가 포함한 객체(this)가 lock이 걸린다.

먼저 첫번째 방법을 해결하는건 간단합니다.

필요한 부분에만 synchronized(this)를 블록으로 처리한다.





#### 2. Atomic

-원자성(Atomicity)의 개념을 띄고 있다. 

(데이터 베이스의 트랜잭션이 모두 성공하거나 모두 실패하는 데이터베이스의 운용집합)

-여러 스레드에서 읽기 쓰기 모두 이용할 수 있다.(CAS  : compare-and-swap)

CAS란 특정 메모리 위치의 값이 주어진 값을 비교하여 같으면 새로운 값으로 대체된다.

(CAS는 Atomic의 핵심 동작 원리이다.)



sync에서 낭비가 심한 문제를 NonBlocking 하면서 동기화 문제를 해결하기 위한 방법이 Atomic 이다.

멀티 스레드환경, 멀티 코어 환경에서 각 CPU는 메인 메모리에서 변수값을 참조하는게 아니라 각 CPU의 캐시 영역에서 메모리를 참조하게 된다.

이 때 메인메모리에 저장된 값과 CPU캐시에 저장된 값이 다른 경우가 있는데(가시성 문제라 한다) 이 때 사용되는 것이 CAS 알고리즘이다. 

즉, **CAS알고리즘**은 현재 스레드에 저장된 값과 메인 메모리에 저장된 값을 비교하여 일치하는 경우 새로운 값으로 교체되고, 일치하지 않는다면 실패하고 재시도를 한다.

(즉, 스레드에서 참조한 값은 캐시메모리에서 참조했는데 캐시메모리는 데이터 miss 날수도 있으니까 스레드가 캐시메모리에서 참조한 값과 메인메모리의 값을 비교하는 구나? )

이런 방법으로 처리하면 CPU 캐시에 잘못된 값을 참조하는 가시성 문제를 해결할 수 있다.



단점은?





#### 3. Volatile

-하나의 스레드가 쓰기 연산을 하고, 다른 스레드에서는 읽기 연산을 통해 최신 값을 가져올 경우, 즉 다른 스레드에서 업데이트를 하지 않는 경우에 이용할 수 있다.

(오직 한 개의 스레드에서 쓰기 작업을 할 때, 그리고 다른 스레드는 읽기작업만을 할 때 안정성을 보장한다.)

- 장점

  volatile로 가시성 문제를 해결할 수 있다.

  volatile을 사용한다면 counter 변수를 읽고 쓰는 과정에서 모든 읽기 쓰기 연산은 메인 메모리에서만 처리된다.  이로써 변수의 가시성 문제를 해결할 수 있게 된다.

- 단점

  하지만 여전히 경쟁 상태 문제가 발생한다.

  메인 메모리만을 이용한다하더라도 동시에 변수를 읽어들이는 상황은 발생하기 때문이다. 

  -> 이는 Atomic의 CAS 방식을 사용하여 해결한다. 







### 궁금한점

 그럼 atomic 과 synchronized는 여러 스레드에서 읽기 쓰기 모두 이용할 수 있는데

방식이 다른데 그럼 어떤 경우에는 atomic 사용하고 어떤경우에 sync를 사용하는가..

또한 장단점이 정확하게 무엇인가?
